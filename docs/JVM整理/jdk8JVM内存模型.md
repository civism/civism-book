# JVM1.8内存模型

### JVM内存模型

<img src="https://tva1.sinaimg.cn/large/006tNbRwly1gazdh1zgrij30va0s0jv9.jpg" alt="image-20200117105648887" style="zoom: 33%;" /> <img src="/Users/gongdexing/Library/Application Support/typora-user-images/image-20200117105708902.png" alt="image-20200117105708902" style="zoom:33%;" />



<img src="https://tva1.sinaimg.cn/large/006tNbRwly1gazdn1v2i5j31060hugpd.jpg" alt="image-20200117110235776" style="zoom:67%;" />



通过上面3张图，图一、图三是1.8的JVM内存分析图，图二是1.7，从上面比对来看，jdk8把JVM分为了**程序计数器**、**虚拟机栈**、**本地方法栈**、**堆**、**元空间**，可以发现元空间取代了1.7中的方法区（永久代)

1.8同1.7比，最大的差别就是：**元数据区取代了永久代**。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：**元数据空间并不在虚拟机中，而是使用本地内存**

#### 程序计数器

> 是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成**当执行Native方法时，计数器的值为空**

#### 虚拟机栈

![image-20200117111430468](https://tva1.sinaimg.cn/large/006tNbRwly1gazdzjseckj31fe0jsgqd.jpg)

> 每个方法被执行的时候都会创建一个"栈帧",用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程

#### 本地方法栈

> 功能与Java虚拟机栈十分相同。区别在于，本地方法栈为虚拟机使用到的native方法服务

#### 堆

![image-20200117111832377](https://tva1.sinaimg.cn/large/006tNbRwly1gaze3nb7qwj31is0ikwkg.jpg)

>  堆是Java 虚拟机所管理的内存中最大的一块。Java 堆是被**所有线程共享**的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是**存放对象实例**，几乎所有的对象实例都在这里分配内存。堆内存分为两个部分：**新生代**和**老年代**, 新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，新生代被划分为3个区域 Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )

#### 元数据区

> **线程共享**，存储已被虚拟机加载的类信息。随着JDK8的到来，JVM不再有方法区（方法区也称"永久代"，它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。），原方法区存储的信息被分成两部分：1、虚拟机加载的类信息，2、运行时常量池，分别被移动到了元空间和堆中

# JVM参数调优

- -Xms设置堆的最小空间大小。
- -Xmx设置堆的最大空间大小。
- -Xmn:设置年轻代大小
- -XX:NewSize设置新生代最小空间大小。
- -XX:MaxNewSize设置新生代最大空间大小。
- -XX:MetaspaceSize设置元数据区最小空间大小。
- -XX:MaxMetaspaceSize设置元数据区最大空间大小。
- -Xss设置每个线程的堆栈大小
- -XX:+UseParallelGC:选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集。
- -XX:ParallelGCThreads:配置并行收集器的线程数,即:同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。

# 感悟

* 线程共享：堆、元数据区，私有：程序计数器、虚拟机栈、本地方法栈
* 程序计时器：标志当前线程所执行的字节码的行号指示器，简单来说：一步执行完了下一步执行啥，可以理解为任务安排表吧
* 虚拟机栈：用于存储局部变量表(包括参数)、操作栈、方法出口等信息
* 本地方法栈：native方法的信息
* 堆：所有对象的内存管理，存放对象实例，运行时常量
* 元数据区：虚拟机加载类信息